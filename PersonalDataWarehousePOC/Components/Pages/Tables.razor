@page "/tables"
@using BlazorDatasheet
@using BlazorDatasheet.Core.Data
@using System.Data
@using BlazorDatasheet.Core.Formats
@using BlazorDatasheet.Menu
@using ExcelDataReader
@using Parquet;
@using Parquet.Schema
@using PersonalDataWarehousePOC.Services
@using System.Text
@inject DataService DataService

<PageTitle>Tables</PageTitle>

<h4>Tables</h4>
<br />

<!-- MAIN UI -->
<div>
    <label style="@(!IsShowFileUpload ? "display:none;" : "")">Open Excel File: </label>
    <br /><br />
    <InputFile @key="resetInputFileFlag" OnChange="HandleFileSelectedAsync" style="@(!IsShowFileUpload ? "display:none;" : "")" />
    @if (IsFileSelected)
    {
        <label>Selected File: @CurrentFileName</label>
        <span>&nbsp; &nbsp;</span>
        <button @onclick="ClearFileSeleted">
            Clear File
        </button>
    }
</div>
<br />
@if (IsLoadingSheet)
{
    <div role="progressbar" class="marquee" style="width: 25%"></div>
}
else
{
    <div>
        @if (TableList.Count > 0)
        {
            @if (CurrentTableName != "")
            {
                <label>Select Table: </label>
                <select @onchange="@(async (args) =>
                    {
                        CurrentTableName = args.Value?.ToString();
                        await LoadTableData(CurrentTableName);
                    })">
                    @foreach (var table in TableList)
                    {
                        <option value="@table" selected="@(table == CurrentTableName ? "selected" : null)">
                            @table
                        </option>
                    }
                </select>
            }
        }
    </div>
    <br />
    <div>
        @if (CurrentDataTable.Rows.Count > 0)
        {
            <button @onclick="Save">Save</button>
            <br />
        }
    </div>
    <br />

    <Datasheet Sheet="@sheet" MenuOptions=_sheetMenuOpt />
}

<!-- POPUPS -->
@if (IsNewTablePopupVisible)
{
    <div class="modal fade show" style="display: block;" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">

                <div class="window glass active">
                    <div class="title-bar">
                        <div class="title-bar-text">New Table</div>
                        <div class="title-bar-controls">
                            <button aria-label="Close" @onclick="CloseNewTablePopup"></button>
                        </div>
                    </div>
                    <div class="window-body has-space">
                        <form @onsubmit="SaveParquetAsync">
                            <div>
                                <label for="tableName">Table Name:</label>
                                <input type="text" id="tableName" maxlength="50" style="width: 300px;" @bind="CurrentTableName" />
                                &nbsp;&nbsp;&nbsp;&nbsp;
                                <button type="submit">Submit</button>
                            </div>
                        </form>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="modal-backdrop fade show"></div>
}

@if (Message != "")
{
    <div class="modal fade show" style="display: block;" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">

                <div class="window glass active">
                    <div class="title-bar">
                        <div class="title-bar-text">Alert!</div>
                        <div class="title-bar-controls">
                            <button aria-label="Close" @onclick="CloseMessagePopup"></button>
                        </div>
                    </div>
                    <div class="window-body has-space">
                        <div class="has-scrollbar" style="width: 300px; height: 100px; overflow: auto">
                            @Message
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="modal-backdrop fade show"></div>
}

@code {
    private Sheet sheet;

    private DataSet dataSet;
    private IBrowserFile CurrentFile;

    List<string> TableList = new List<string>();
    List<string> TableColumns = new List<string>();
    List<string> colGeneralErrors = new List<string>();
    DataTable CurrentDataTable = new DataTable();
    string CurrentTableName = string.Empty;
    string CurrentFileName = string.Empty;

    string Message = "";

    bool resetInputFileFlag = false;
    bool IsFileSelected = false;
    bool IsShowFileUpload = true;
    bool IsLoadingSheet = false;
    bool IsNewTablePopupVisible = false;

    SheetMenuOptions _sheetMenuOpt = new SheetMenuOptions()
        {
            InsertColsEnabled = false,
            HideColsEnabled = false,
            HideRowsEnabled = false,
            DeleteColsEnabled = false,
            MergeEnabled = false,
            SortRangeEnabled = false,
            FilterColumnEnabled = false,
            HeaderMenuEnabled = false,
            AlignmentEnabled = false,
            ClearEnabled = false
        };

    protected override async Task OnInitializedAsync()
    {
        // Initialize the sheet
        sheet = new Sheet(10, 10);

        LoadTableListDropdown();

        // If TableList has items, load the first table
        if (TableList.Count > 0)
        {
            CurrentTableName = TableList[0];
            await LoadTableData(CurrentTableName);
        }
    }

    // Events

    private async Task HandleFileSelectedAsync(InputFileChangeEventArgs e)
    {
        if (e.File == null)
        {
            return;
        }

        CurrentTableName = string.Empty;
        CurrentFile = e.File;
        CurrentFileName = CurrentFile.Name;

        IsShowFileUpload = false;
        IsLoadingSheet = true;
        StateHasChanged();

        using var fileStream = CurrentFile.OpenReadStream();

        System.Text.Encoding.RegisterProvider(System.Text.CodePagesEncodingProvider.Instance);

        using var memoryStream = new MemoryStream();
        await fileStream.CopyToAsync(memoryStream);
        memoryStream.Position = 0;

        using var reader = ExcelReaderFactory.CreateReader(memoryStream);
        var result = reader.AsDataSet(new ExcelDataSetConfiguration()
            {
                ConfigureDataTable = _ => new ExcelDataTableConfiguration()
                {
                    UseHeaderRow = true
                }
            });

        dataSet = result;

        // Load dataSet into DataTable
        if (dataSet != null && dataSet.Tables.Count > 0)
        {
            CurrentDataTable = dataSet.Tables[0];
            await LoadTableData();
        }

        CurrentFile = null;
        IsLoadingSheet = false;
        IsFileSelected = true;
        StateHasChanged();
    }

    private void ClearFileSeleted()
    {
        // Toggle the flag to force a re-render of InputFile
        resetInputFileFlag = !resetInputFileFlag;

        // Reset the variables
        IsFileSelected = false;
        IsShowFileUpload = true;

        LoadTableListDropdown();
    }

    // Table Dropdown

    private void LoadTableListDropdown()
    {
        IsLoadingSheet = true;
        StateHasChanged();

        TableList = new List<string>();

        // Load the TableList data
        var parquetFolder = Path.Combine("Data", "Parquet");
        if (Directory.Exists(parquetFolder))
        {
            TableList = Directory.GetFiles(parquetFolder, "*.parquet")
                                 .Select(Path.GetFileNameWithoutExtension)
                                 .ToList();
        }

        IsLoadingSheet = false;
        StateHasChanged();
    }

    private async Task LoadTableData(string paramTable)
    {
        IsLoadingSheet = true;
        StateHasChanged();

        // Load the DataTable
        var parquetFolder = Path.Combine("Data", "Parquet");
        var fileName = Path.Combine(parquetFolder, $"{paramTable}.parquet");

        if (System.IO.File.Exists(fileName))
        {
            CurrentDataTable = await DataService.ReadParquetFileAsync(fileName);
            await LoadTableData();
        }
        else
        {
            Message = "Table not found.";
        }

        IsLoadingSheet = false;
        StateHasChanged();
    }

    private async Task LoadTableData()
    {
        Message = "";

        // Get a list of the columns from the DataTable
        TableColumns = CurrentDataTable.Columns.Cast<DataColumn>().Select(x => x.ColumnName).ToList();

        // Create sheet with the number of columns
        sheet = new Sheet(CurrentDataTable.Rows.Count, TableColumns.Count);

        // Wait 1 second before loading the table data
        // to join the UI thread
        await Task.Delay(1000);

        // Turn off history
        sheet.BatchUpdates();
        sheet.Commands.PauseHistory();

        int i = 0;
        foreach (string objDatabaseColumn in TableColumns)
        {
            sheet.Columns.SetHeadings(i, i, objDatabaseColumn);
            i++;
        }

        int ii = 0;
        foreach (DataRow dataRow in CurrentDataTable.Rows)
        {
            i = 0;
            foreach (string objDatabaseColumn in TableColumns)
            {
                // Set the value of the cell
                sheet.Cells[ii, i].Value = dataRow[i].ToString();
                sheet.Cells[ii, i].Format = new CellFormat() { IsReadOnly = false };
                sheet.Cells[ii, i].Type = "string";
                i++;
            }

            ii++;
        }

        // Turn on history
        sheet.EndBatchUpdates();
        sheet.Commands.ResumeHistory();
    }

    // Save

    private async Task Save()
    {
        if (CurrentTableName.Trim().Length == 0)
        {
            // Open the New Table popup
            IsNewTablePopupVisible = true;
        }
        else
        {
            // Save the Parquet file
            await SaveParquetAsync();
        }
    }

    private async Task SaveParquetAsync()
    {
        // Only run these checks on a new Table
        if (IsNewTablePopupVisible == true)
        {
            if (CurrentTableName.Trim().Length == 0)
            {
                Message = "Table Name is required.";
                return;
            }

            if (DetectDuplicate(CurrentTableName))
            {
                Message = "Table Name already exists.";
                return;
            }
        }

        CurrentTableName = CleanAndCapitalize(CurrentTableName);

        IsLoadingSheet = true;
        StateHasChanged();

        // Convert sheet to datatable
        ConvertSheetToDataTable();

        // Convert to Parquet
        await ConvertToParquet();

        // Create C# class from DataTable
        GenerateClassFromDataTable(CurrentDataTable, CurrentTableName);

        // Re-Load the TableList dropdown
        LoadTableListDropdown();

        // Toggle the flag to force a re-render of InputFile
        // Clearing it if needed
        resetInputFileFlag = !resetInputFileFlag;

        IsLoadingSheet = false;
        IsNewTablePopupVisible = false;
        StateHasChanged();

        Message = $"{CurrentTableName} saved successfully.";
    }

    // Popups

    private void CloseNewTablePopup()
    {
        IsNewTablePopupVisible = false;
    }

    private void CloseMessagePopup()
    {
        Message = "";
    }

    // Datasheet Operations

    #region private void ConvertSheetToDataTable
    private void ConvertSheetToDataTable()
    {
        colGeneralErrors = new List<string>();
        CurrentDataTable = new DataTable();

        foreach (var column in TableColumns)
        {
            CurrentDataTable.Columns.Add(new DataColumn(column, typeof(String)));
        }

        for (int i = 0; i < sheet.NumRows; i++)
        {
            DataRow row = CurrentDataTable.NewRow();

            for (int j = 0; j < TableColumns.Count; j++)
            {
                try
                {
                    var cellValue = sheet.Cells[i, j]?.Value;

                    if (cellValue == null || cellValue == DBNull.Value || string.IsNullOrWhiteSpace(cellValue.ToString()))
                    {
                        row[j] = DBNull.Value;
                    }
                    else
                    {
                        var columnType = CurrentDataTable.Columns[j].DataType;

                        if (columnType == typeof(int))
                        {
                            row[j] = Convert.ToInt32(cellValue);
                        }
                        else if (columnType == typeof(DateTime))
                        {
                            row[j] = Convert.ToDateTime(cellValue);
                        }
                        else if (columnType == typeof(TimeSpan))
                        {
                            string stringValue = cellValue.ToString();

                            if (DateTime.TryParse(stringValue, out var parsedDateTime))
                            {
                                row[j] = parsedDateTime.TimeOfDay;
                            }
                            else if (TimeSpan.TryParse(stringValue, out var parsedTimeSpan))
                            {
                                row[j] = parsedTimeSpan;
                            }
                            else
                            {
                                row[j] = stringValue;
                            }
                        }
                        else
                        {
                            string cleanValue = cellValue.ToString()
                                .Replace("\r\n", " ")
                                .Replace("\t", " ")
                                .Replace("\r", " ")
                                .Replace("\n", " ")
                                .Trim();

                            row[j] = cleanValue;
                        }
                    }
                }
                catch (Exception ex)
                {
                    colGeneralErrors.Add(ex.GetBaseException().Message);
                }
            }

            CurrentDataTable.Rows.Add(row);
        }
    }
    #endregion

    #region private async Task ConvertToParquet
    private async Task ConvertToParquet()
    {
        int columnCount = CurrentDataTable.Columns.Count;
        int lastColumnIndex = columnCount - 1;

        // Prepare fields for all columns

        var parquetFields = new List<Field>(columnCount);
        for (int i = 0; i < columnCount; i++)
        {
            string columnName = CurrentDataTable.Columns[i].ColumnName;
            parquetFields.Add(new DataField<string>(columnName));
        }

        ParquetSchema parquetSchema = new ParquetSchema(parquetFields);
        var parquetTable = new Parquet.Rows.Table(parquetSchema);

        foreach (DataRow dataRow in CurrentDataTable.Rows)
        {
            // Initialize the row with a pre-sized string array
            var row = new Parquet.Rows.Row(new string[columnCount]);

            for (int j = 0; j < lastColumnIndex; j++)
            {
                string value = dataRow[j]?.ToString() ?? string.Empty;

                if (!string.IsNullOrEmpty(value))
                {
                    // Using chained Replace calls for clarity and performance
                    value = value.Replace("\r\n", " ")
                                 .Replace("\t", " ")
                                 .Replace("\r", " ")
                                 .Replace("\n", " ")
                                 .Trim();
                }

                row[j] = value;
            }

            parquetTable.Add(row);
        }

        using var ms = new MemoryStream();
        await parquetTable.WriteAsync(ms); // Await for async write
        ms.Position = 0;

        string fileName = $"Data/Parquet/{CurrentTableName}.parquet";
        using (var fileStream = new FileStream(fileName, FileMode.Create, FileAccess.Write))
        {
            ms.CopyTo(fileStream);
        }
    }
    #endregion

    #region public static void GenerateClassFromDataTable(DataTable dt, string className)
    public static void GenerateClassFromDataTable(DataTable dt, string className)
    {
        // Define directory for output
        string directoryPath = Path.Combine("Data", "Classes");
        Directory.CreateDirectory(directoryPath);

        // Start building the class code
        StringBuilder codeBuilder = new StringBuilder();
        codeBuilder.AppendLine("using System;");
        codeBuilder.AppendLine();
        codeBuilder.AppendLine($"namespace Data");
        codeBuilder.AppendLine("{");
        codeBuilder.AppendLine($"    public class {className}");
        codeBuilder.AppendLine("    {");

        // For each column in the DataTable, create a string property
        foreach (DataColumn column in dt.Columns)
        {
            // Ensure the property name is a valid C# identifier
            string propertyName = column.ColumnName.Replace(" ", "_"); // Simple replacement, customize as needed
            codeBuilder.AppendLine($"        public string {propertyName} {{ get; set; }}");
        }

        codeBuilder.AppendLine("    }");
        codeBuilder.AppendLine("}");

        // Set the file path
        string filePath = Path.Combine(directoryPath, className + ".cs");

        // Write the class to file
        File.WriteAllText(filePath, codeBuilder.ToString());
    }
    #endregion

    // Utility

    #region public static string CleanAndCapitalize(string input)
    public static string CleanAndCapitalize(string input)
    {
        if (string.IsNullOrEmpty(input))
            return string.Empty;

        // 1) Keep only letters, digits, and spaces (temporarily), removing all other characters
        //    We keep spaces initially to determine word boundaries for capitalization.
        char[] filteredChars = input
            .Where(c => char.IsLetterOrDigit(c) || char.IsWhiteSpace(c))
            .ToArray();

        // Convert to a string to process spaces and capitalization
        string intermediate = new string(filteredChars);

        // 2) Remove spaces and capitalize the following character if it is a letter
        // We'll build the result using a StringBuilder for efficiency.
        var result = new System.Text.StringBuilder();
        bool capitalizeNext = false;

        for (int i = 0; i < intermediate.Length; i++)
        {
            char c = intermediate[i];

            if (char.IsWhiteSpace(c))
            {
                // Encountered a space: the next valid letter should be capitalized if it's not a digit.
                capitalizeNext = true;
            }
            else
            {
                // This character is alphanumeric. If we are instructed to capitalize it and it's a letter:
                if (capitalizeNext && char.IsLetter(c))
                {
                    c = char.ToUpper(c);
                }

                result.Append(c);
                capitalizeNext = false; // Reset flag after processing a non-space character
            }
        }

        return result.ToString();
    }
    #endregion

    #region public static bool DetectDuplicate(string paramTableName)
    public static bool DetectDuplicate(string paramTableName)
    {
        // Check if the table name already exists
        string fileName = $"Data/Parquet/{paramTableName}.parquet";
        return System.IO.File.Exists(fileName);
    }
    #endregion
}